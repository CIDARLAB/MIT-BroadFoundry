#!/usr/bin/env python
"""
	Run eXpress for a given set of designs

	This script will run eXpress that takes unmapped read data and a set of
	potential transcripts and will estimate expression of those based on a 
	statistical model. Here we use Bowie to preform the mapping step and
	importantly allow for unlimited potential multi-mappings to account
	for different transcript forms (i.e., due to read-through). 
"""
#	Copyright (C) 2014 by
#	Thomas E. Gorochowski <tom@chofski.co.uk>, Voigt Lab, MIT
# 	All rights reserved.
#	OSI Non-Profit Open Software License ("Non-Profit OSL") 3.0 license.

# Required modules
import os
import csv
import subprocess
import argparse

###############################################################################
# SUPPORTING FUNCTIONS
###############################################################################

def load_fastq_file_mapping (filename):
	"""Load the locations of the raw fastq data.
	"""
	fastq_file_map = {}
	data_reader = csv.reader(open(filename, 'rU'), delimiter=',')
	# Ignore header
	header = next(data_reader)
	# Process each line
	for row in data_reader:
		if len(row) == 3:
			# 1 = Upstream, 2 = Downstream
			fastq_file_map[row[0]] = [row[1],row[2]]
	return fastq_file_map

def create_dir_if_needed (directory):
	"""Create a directory if it doesn't exist
	"""
	if not os.path.exists(directory):
		try:
			os.makedirs(directory)
		except IOError as e:
			print("WARNING: Directory already exists.")

def merge_fasta_files (fasta_file_1, fasta_file_2, fasta_file_out):
	"""Merge the contents of 2 FASTA files
	"""
	f_out = open(fasta_file_out, 'w')
	f1_in = open(fasta_file_1, 'r')
	for line in f1_in:
		f_out.write(line)
	f1_in.close()
	f_out.write('\n')
	f2_in = open(fasta_file_2, 'r')
	for line in f2_in:
		f_out.write(line)
	f2_in.close()
	f_out.close()

###############################################################################
# RUN THE WORKFLOW
###############################################################################

def run_express (designs_to_process, FASTQ_PREFIX, DATA_PREFIX, RESULTS_PREFIX, CLEAN_UP):
	"""Run eXpress on a set of designs
	"""

	# Results are stored in these directories
	fasta_out_dir = RESULTS_PREFIX+'fasta/'
	refs_out_dir = RESULTS_PREFIX+'refs/'
	#refs_gene_out_dir = RESULTS_PREFIX+'refs_gene/'
	express_out_dir = RESULTS_PREFIX+'exp_transcript/'
	express_gene_out_dir = RESULTS_PREFIX+'exp_gene/'

	# Location of mapping from design to raw read files
	FASTQ_MAP_FILENAME = DATA_PREFIX+'fastq_mapping.csv'

	# Load the FASTQ filename to design mapping 
	fastq_mapping = load_fastq_file_mapping(FASTQ_MAP_FILENAME)
	
	# Create a location to save the Bowtie indexes and reference TUs
	create_dir_if_needed(refs_out_dir)

	# Create a location to save the Bowtie indexes and reference TUs
	#create_dir_if_needed(refs_gene_out_dir)

	# For each design process with eXpress
	for design in designs_to_process:

		# -----------------------------------------------------------------------------
		# 1. BUILD BOWTIE INDEX
		#    Requirements:
		#    - Transcript FASTA file (tu_arch generated by GeneClusterLibrary)
		#    - Genome FASTA file (all transcripts of the host, or ORFs as proxy)
		# -----------------------------------------------------------------------------
		
		# Check that we have the TU architecture for the design
		ref_tu_arch_in = DATA_PREFIX+'tu_archs/tu_arch_'+design+'.fa'
		ref_genome_in  = DATA_PREFIX+'host_gene_seqs.fa'
		ref_syn_genes_in  = DATA_PREFIX+'syn_gene_seqs.fa'
		ref_tus = ''
		clean_ref_tus = False
		if os.path.isfile(ref_tu_arch_in) == False:
			print 'express_run.py ERROR:', ref_tu_arch_in, 'not found, skipping design', design, '.'
		else:

			# MAPPING WITH BOWTIE
			# -------------------

			# Merge gene sequences for circuit and genome
			ref_tus = refs_out_dir+design+'.fa'
			merge_fasta_files (ref_genome_in, ref_tu_arch_in, ref_tus)

			bwa_ref_out_file = refs_out_dir+'bwa_'+design				
			cmd_bwa_build_idx = 'bwa index -p ' + \
			                        bwa_ref_out_file + ' ' + \
			                        ref_tus
			print 'express-run.py RUNNING:', cmd_bwa_build_idx
			subprocess.call(cmd_bwa_build_idx, shell=True)

			# EXPRESSION ESTIMATION (BWA for gene-level)
			# ------------------------------------------

			# Find the raw file names
			fastq_filenames = fastq_mapping[design]

			# Create somewhere to save eXpress expression estimate data
			create_dir_if_needed(express_out_dir+'/'+design)

			# Use BWA for gene mapping - we do not want multi-mapped reads here (better quality)
			#'bwa mem -t 4 ./hg19.fasta ./s1_1.fastq ./s1_2.fastq > s1.sam'
			cmd_express_exp_ests = 'bwa mem -a -t 4 ' + \
								    bwa_ref_out_file + ' ' + \
			                        FASTQ_PREFIX + fastq_filenames[0] + ' ' + \
			                        FASTQ_PREFIX + fastq_filenames[1] + ' | ' + \
			                        'express ' + ref_tus + ' ' + \
			                        '-o ' + express_out_dir + design
			print 'express_run.py RUNNING:', cmd_express_exp_ests
			subprocess.call(cmd_express_exp_ests, shell=True)

			# Clean-up by removing Bowtie index for design
			if CLEAN_UP == True:
				cmd_clean_up = 'rm ' + bwa_ref_out_file + '*.*'
				subprocess.call(cmd_clean_up, shell=True)
				cmd_clean_up = 'rm ' + ref_tus
				subprocess.call(cmd_clean_up, shell=True)

		# -----------------------------------------------------------------------------
		# 3. PERFORM MAPPING AND EXPRESSION QUANTIFICATION FOR HOST AND SYN GENE SEQS
		#    Requirements:
		#    - Genome FASTA file (ORFs as proxy)
		#    - Synethic Genes FASTA file (ORFs as proxy)
		#    - Raw reads in FASTQ format (assumes paired-end reads)
		# -----------------------------------------------------------------------------

		if design not in fastq_mapping.keys():
			print 'express_run.py ERROR:', design, 'not found in fastq_mapping, skipping.'
		else:
			if os.path.isfile(ref_genome_in) == False or os.path.isfile(ref_syn_genes_in) == False:
				print 'express_run.py ERROR: host and syn gene sequences not found, skipping step for design', design, '.'
			else:

				# MAPPING WITH BOWTIE
				# -------------------

				# Merge gene sequences for circuit and genome
				ref_tus = refs_out_dir+'genes_'+design+'.fa'
				merge_fasta_files (ref_genome_in, ref_syn_genes_in, ref_tus)

				bwa_ref_out_file = refs_out_dir+'bwa_genes_'+design				
				cmd_bwa_build_idx = 'bwa index -p ' + \
				                        bwa_ref_out_file + ' ' + \
				                        ref_tus
				print 'express-run.py RUNNING:', cmd_bwa_build_idx
				subprocess.call(cmd_bwa_build_idx, shell=True)

				# EXPRESSION ESTIMATION (BWA for gene-level)
				# ------------------------------------------

				# Find the raw file names
				fastq_filenames = fastq_mapping[design]

				# Create somewhere to save eXpress expression estimate data
				create_dir_if_needed(express_gene_out_dir+'/'+design)

				# Use BWA for gene mapping - we do not want multi-mapped reads here (better quality)
				#'bwa mem -t 4 ./hg19.fasta ./s1_1.fastq ./s1_2.fastq > s1.sam'
				cmd_express_exp_ests = 'bwa mem -t 4 ' + \
									    bwa_ref_out_file + ' ' + \
				                        FASTQ_PREFIX + fastq_filenames[0] + ' ' + \
				                        FASTQ_PREFIX + fastq_filenames[1] + ' | ' + \
				                        'express ' + ref_tus + ' ' + \
				                        '-o ' + express_gene_out_dir + design
				print 'express_run.py RUNNING:', cmd_express_exp_ests
				subprocess.call(cmd_express_exp_ests, shell=True)

				# Clean-up by removing Bowtie index for design
				if CLEAN_UP == True:
					cmd_clean_up = 'rm ' + bwa_ref_out_file + '*.*'
					subprocess.call(cmd_clean_up, shell=True)
					cmd_clean_up = 'rm ' + ref_tus
					subprocess.call(cmd_clean_up, shell=True)


###############################################################################
# MAIN FUNCTION
###############################################################################

def main():
	# Parse the command line inputs
	parser = argparse.ArgumentParser(description="eXpress run")
	parser.add_argument("-designs",  dest="designs",  required=True,  help="1,2,3", metavar="string")
	parser.add_argument("-fastq_prefix",  dest="fastq_prefix",  required=True,  help="/fastq/", metavar="string")
	parser.add_argument("-data_prefix",  dest="data_prefix",  required=True,  help="/data/", metavar="string")
	parser.add_argument("-results_prefix",  dest="results_prefix",  required=True,  help="/results/", metavar="string")
	parser.add_argument("-clean_up",  dest="clean_up",  required=False,  help="Y", metavar="string")
	args = parser.parse_args()
	# Set global variables
	FASTQ_PREFIX = args.fastq_prefix
	DATA_PREFIX = args.data_prefix
	RESULTS_PREFIX = args.results_prefix
	CLEAN_UP = False
	if args.clean_up == 'Y':
		CLEAN_UP = True
	# Extract the designs to process and run
	designs_to_process = args.designs.split(',')
	# Run RSEM commands
	run_express(designs_to_process, FASTQ_PREFIX, DATA_PREFIX, RESULTS_PREFIX, CLEAN_UP)

if __name__ == "__main__":
	main()
